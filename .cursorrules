# Portfolio App - Engineering Constitution (.cursorrules)

## üéØ Project Context
This is an iOS portfolio app demonstrating Staff-level engineering practices. Built with SwiftUI, Clean Architecture, and MVVM-Coordinator pattern. The codebase prioritizes developer velocity, team scalability, and production excellence.

## üèó Architecture Rules

### Layer Separation
```
Domain Layer (Pure Business Logic)
    ‚Üì depends on nothing
Data Layer (Services & Repositories)  
    ‚Üì depends on Domain
Presentation Layer (Views & ViewModels)
    ‚Üì depends on Domain
Coordinator Layer (Navigation)
    ‚Üì orchestrates Presentation
```

### Domain Layer Rules
- **NO** UIKit/SwiftUI imports
- **NO** external dependencies
- **YES** pure Swift only
- **YES** immutable models
- **YES** protocol boundaries

### Data Layer Rules
- **ALWAYS** use protocols for services
- **ALWAYS** async/await for async operations
- **NEVER** expose implementation details
- **NEVER** use singletons

### Presentation Layer Rules
- **ViewModels** must be `@MainActor`
- **Views** must be pure, no business logic
- **ALWAYS** use `@StateObject` for ViewModel ownership
- **NEVER** call services directly from Views

## üíª Code Style Mandates

### Naming Conventions
```swift
// ‚úÖ CORRECT
struct PortfolioView: View { }
final class PortfolioViewModel: ObservableObject { }
protocol PortfolioService { }
final class PortfolioServiceImpl: PortfolioService { }

// ‚ùå WRONG
struct Portfolio: View { }  // Missing 'View' suffix
class PortfolioVM { }  // Use full 'ViewModel'
class PortfolioServiceManager { }  // Don't use 'Manager'
```

### Async/Await Pattern
```swift
// ‚úÖ CORRECT - Modern Swift Concurrency
func fetchData() async throws -> Model {
    try await service.fetch()
}

// ‚ùå WRONG - Old completion handlers
func fetchData(completion: @escaping (Result<Model, Error>) -> Void) {
    // Don't use this pattern
}
```

### Dependency Injection
```swift
// ‚úÖ CORRECT - Constructor injection
final class ViewModel {
    private let service: ServiceProtocol
    
    init(service: ServiceProtocol) {
        self.service = service
    }
}

// ‚ùå WRONG - Singleton pattern
class ServiceManager {
    static let shared = ServiceManager()  // NEVER do this
}
```

### Error Handling
```swift
// ‚úÖ CORRECT - Typed errors with recovery
enum FeatureError: LocalizedError {
    case networkFailure
    
    var errorDescription: String? {
        NSLocalizedString("error.network", comment: "")
    }
    
    var recoverySuggestion: String? {
        NSLocalizedString("error.network.recovery", comment: "")
    }
}

// ‚ùå WRONG - Generic errors
throw NSError(domain: "", code: 0)  // Too generic
```

## üß™ Testing Requirements

### Use Swift Testing for New Tests
```swift
// ‚úÖ CORRECT - Modern Swift Testing
import Testing

@Suite("Feature Tests")
struct FeatureTests {
    @Test("Validates input correctly")
    func validateInput() {
        #expect(validator.isValid("test") == true)
    }
}

// ‚ö†Ô∏è Use XCTest only for complex async scenarios
import XCTest

class ComplexAsyncTests: XCTestCase {
    func test_complexAsync() async throws {
        // Only when Swift Testing doesn't suffice
    }
}
```

### Mock Pattern
```swift
// ‚úÖ CORRECT - Protocol-based mocking
class MockService: ServiceProtocol {
    var mockResult: Result<Model, Error>?
    
    func fetch() async throws -> Model {
        switch mockResult {
        case .success(let model): return model
        case .failure(let error): throw error
        case .none: throw TestError.notConfigured
        }
    }
}
```

## ‚ôøÔ∏è Accessibility Mandates

### Every UI Element Must Be Accessible
```swift
// ‚úÖ CORRECT
Text("Balance: \(amount)")
    .accessibilityLabel("Account balance: \(formattedAmount)")
    .accessibilityHint("Double tap to see transaction history")

// ‚ùå WRONG
Text("Balance: \(amount)")  // Missing accessibility
```

### Group Related Content
```swift
// ‚úÖ CORRECT
VStack {
    Text(title)
    Text(subtitle)
}
.accessibilityElement(children: .combine)
.accessibilityLabel("\(title), \(subtitle)")
```

## üåç Internationalization

### All Strings Must Be Localized
```swift
// ‚úÖ CORRECT
Text(NSLocalizedString("welcome.title", comment: "Welcome screen title"))

// ‚ùå WRONG  
Text("Welcome")  // Hard-coded string
```

### Format Numbers and Dates
```swift
// ‚úÖ CORRECT
let formatter = NumberFormatter()
formatter.numberStyle = .currency
Text(formatter.string(from: amount) ?? "")

// ‚ùå WRONG
Text("$\(amount)")  // Assumes USD and US formatting
```

## üîí Security Rules

### API Key Management
```swift
// ‚úÖ CORRECT
let apiKey = Bundle.main.object(forInfoDictionaryKey: "APIKey") as? String

// ‚ùå WRONG
let apiKey = "sk_live_abc123"  // NEVER hardcode
```

### Sensitive Data
```swift
// ‚úÖ CORRECT - Use Keychain
KeychainService.store(token, for: "authToken")

// ‚ùå WRONG - UserDefaults for sensitive data
UserDefaults.standard.set(token, forKey: "authToken")
```

## üìä Performance Standards

### Required Metrics
- App launch: <1 second
- Screen transitions: 60fps
- Memory baseline: <50MB
- Network timeout: 30 seconds
- Image cache: 100MB max

### Optimization Patterns
```swift
// ‚úÖ CORRECT - Lazy loading
LazyVStack {
    ForEach(items) { item in
        ItemRow(item: item)
    }
}

// ‚ùå WRONG - Loading everything
VStack {
    ForEach(items) { item in
        ItemRow(item: item)
    }
}
```

## üîÑ Git Workflow

### Commit Message Format
```
<type>: <subject>

<body>

<footer>
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `perf`

### Branch Naming
- `feature/` - New features
- `fix/` - Bug fixes  
- `chore/` - Maintenance
- `docs/` - Documentation only

## üìù Documentation Requirements

### Public APIs Must Have Documentation
```swift
/// Fetches portfolio data for the given wallet address
/// - Parameter address: Ethereum wallet address (0x...)
/// - Returns: Portfolio containing tokens and NFTs
/// - Throws: `NetworkError` if request fails
public func fetchPortfolio(for address: String) async throws -> Portfolio {
    // Implementation
}
```

### Complex Logic Needs Explanation
```swift
// Calculate weighted average price
// Formula: Œ£(price √ó quantity) / Œ£(quantity)
// Handles edge case where total quantity is zero
```

## üöÄ AI Assistant Instructions

When generating code for this project:

1. **Always follow the architecture patterns** - Don't break layer boundaries
2. **Use modern Swift patterns** - async/await, Swift Testing, property wrappers
3. **Include accessibility** - Every UI element must be accessible
4. **Write testable code** - Dependency injection, protocols, pure functions
5. **Consider performance** - Lazy loading, caching, efficient algorithms
6. **Add documentation** - Public APIs and complex logic
7. **Localize strings** - No hardcoded user-facing text
8. **Handle errors gracefully** - Typed errors with recovery suggestions

## üéØ Code Generation Templates

### New Feature Module
When creating a new feature, generate all layers:
1. Domain models (pure Swift structs)
2. Service protocols and implementations  
3. ViewModels with `@Published` properties
4. SwiftUI Views with accessibility
5. Coordinator for navigation
6. Unit tests using Swift Testing
7. UI test example

### New Service
```swift
protocol [Feature]Service: AnyObject {
    func fetch() async throws -> [Model]
}

final class [Feature]ServiceImpl: [Feature]Service {
    private let networkService: NetworkService
    
    init(networkService: NetworkService) {
        self.networkService = networkService
    }
    
    func fetch() async throws -> [Model] {
        // Implementation
    }
}
```

### New ViewModel
```swift
@MainActor
final class [Feature]ViewModel: ObservableObject {
    @Published private(set) var state: ViewState = .idle
    @Published var model: [Model]?
    
    enum ViewState {
        case idle, loading, loaded, error(Error)
    }
    
    private let service: [Feature]Service
    
    init(service: [Feature]Service) {
        self.service = service
    }
    
    func load() async {
        state = .loading
        do {
            model = try await service.fetch()
            state = .loaded
        } catch {
            state = .error(error)
        }
    }
}
```

## üìã Review Checklist

Before approving any code:
- [ ] Follows architecture patterns
- [ ] Has appropriate tests
- [ ] Includes accessibility labels
- [ ] Strings are localized
- [ ] No hardcoded values
- [ ] Errors handled gracefully
- [ ] Documentation complete
- [ ] Performance considered

## üö® Red Flags to Avoid

1. **Force unwrapping** - Use if-let or guard
2. **Synchronous network calls** - Always async
3. **Massive views** - Break into components
4. **Business logic in views** - Move to ViewModel
5. **Missing error handling** - Always handle failures
6. **Hardcoded strings** - Must be localized
7. **Singletons** - Use dependency injection
8. **God objects** - Single responsibility principle
9. **Untested code** - Minimum 70% coverage
10. **Inaccessible UI** - Must support VoiceOver

---

**Version**: 1.0.0
**Last Updated**: 2024
**Maintained By**: iOS Platform Team

This is our engineering constitution. When in doubt, refer to these principles. They are not suggestions - they are requirements for maintaining a Staff-level codebase.